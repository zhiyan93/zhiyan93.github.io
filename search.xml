<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ScrollView一点经验总结</title>
      <link href="/2020/05/20/scrollview/"/>
      <url>/2020/05/20/scrollview/</url>
      
        <content type="html"><![CDATA[<p>废寝忘食做了一个半月的IE毕业设计总算是搞完了。 之后会陆续总结一些学到的东西，帮助一些搞不懂这些问题的人，也是怕自己忘了。<br>先说iOS程序里的一个很基本的功能，scrollview。这个东西其实不难，网上能搜到很多教你怎么做的，我视频加文字看了七八篇吧，但是只是教你一步步去做罢了，能把道理讲清楚的不多。</p><h2 id="1-怎么做出来"><a href="#1-怎么做出来" class="headerlink" title="1.  怎么做出来"></a>1.  怎么做出来</h2><p>  做scrollview简单来说就是一句话，“八0两等一弱”，简称821.</p><p>  先在一个空的View上放一个ScrollView，在这个scrollview的size inspector界面把这个Content Layout Guides选项去掉。</p><p>  <img src="/2020/05/20/scrollview/layoutguide.png" srcset="/img/loading.gif" alt="layoutguide" width="300"></p><p> 这时候View的结构如下所示。</p><p>  <img src="/2020/05/20/scrollview/viewstructure1.png" srcset="/img/loading.gif" alt="constraints1" width="300"></p><p>拖动这个ScrollView的四条边，分别和空白View的SafeArea对齐，然后在ScrollView的Constraints面板上设置到空白View的四个边距离都为0.<br><img src="/2020/05/20/scrollview/cons1.png" srcset="/img/loading.gif" alt="constraints1" width="300"></p><p>在Library里找到View，放到ScrollView里。</p><p><img src="/2020/05/20/scrollview/ContentView.png" srcset="/img/loading.gif" alt="ContentView" width="300"></p><p>这时候的View Structure是这样的：</p><p><img src="/2020/05/20/scrollview/ViewStructure2.png" srcset="/img/loading.gif" alt="ViewStructure2" width="300"></p><p>为了不搞混，这里把这个View的名字改成ContentView（选中这个View，一秒之后再点击一下可以改名）</p><p><img src="/2020/05/20/scrollview/renamecontent.png" srcset="/img/loading.gif" alt="viewrename" width="300"></p><p>和之前一样，我们也把这个ContentView的四边和ScrollView的四边对齐，然后设置边的constraints，设置四个0.</p><p><img src="/2020/05/20/scrollview/cons2.png" srcset="/img/loading.gif" alt="constraints2" width="300"></p><p>以上总共设置了八个0，这个就是821的8.</p><p>选中ContentView，按住Control并拖动到ScrollView，再弹出的窗口中选择””Equal Widths”</p><p><img src="/2020/05/20/scrollview/equalwidth.png" srcset="/img/loading.gif" alt="equalwidth" width="300"></p><p>重复上述步骤，在弹出窗口中选择“Equal Heights”</p><p>这个时候View界面上是不会出现红色的错误提示的，Constraints Structure现在如下图所示。</p><p><img src="/2020/05/20/scrollview/structure3.png" srcset="/img/loading.gif" alt="structure3" width="300"></p><p>以上步骤设置了两个相等，equal widths和equal height，就是821的2。</p><p>这时候在view structure里点击这个ContentView, 并选中它的高度</p><p><img src="/2020/05/20/scrollview/viewheight1.png" srcset="/img/loading.gif" alt="viewheight1" width="300"></p><p>在右侧的size inspector选项卡里把这个高度的Priority值设置成Low(250)</p><p><img src="/2020/05/20/scrollview/hightsizelow.png" srcset="/img/loading.gif" alt="hightsize" width="300"></p><p>这时候这个ContentView的Height就从实线变成了虚线。</p><p><img src="/2020/05/20/scrollview/viewheight2.png" srcset="/img/loading.gif" alt="hightsize" width="300"></p><p>以上步骤设置了一个Low priority，就是821里面的1.</p><p>这时候这个ScrollView就设置完成了，我们可以加点东西来测试一下。我们放两个Button，一个靠上面，一个靠下面（我调了颜色）。</p><p><img src="/2020/05/20/scrollview/twobutton.png" srcset="/img/loading.gif" alt="hightsize" width="300"></p><p>上面的Button指定它和ContentView的上左右三个距离和它的高度<br><img src="/2020/05/20/scrollview/btnconstraint1.png" srcset="/img/loading.gif" alt="hightsize" width="300"></p><p>下面的Button指定它和ContentView的下左右三个距离和它的高度<br><img src="/2020/05/20/scrollview/btnconstraint2.png" srcset="/img/loading.gif" alt="hightsize" width="300"></p><p>之后选中一个Button，按住Control，拖动到另一个Button，在弹出的窗口中选择”Vertical Specing”</p><p><img src="/2020/05/20/scrollview/verticalspecing.png" srcset="/img/loading.gif" alt="hightsize" width="300"></p><p>选中这个两个Button之间的Constraint</p><p><img src="/2020/05/20/scrollview/verticalcons.png" srcset="/img/loading.gif" alt="vertical constraints" width="300"></p><p>在右侧size inspector界面里把这个Constant的值改一个大点的值(我这里改成了1200)</p><p><img src="/2020/05/20/scrollview/verticalvalue.png" srcset="/img/loading.gif" alt="vertical constraints" width="300"></p><p>之后可以看到下面的按钮跑到界面下面去了, 选中ContentView，滑动鼠标可以看到下面的那部分ContentView。</p><p><img src="/2020/05/20/scrollview/valuechanged.png" srcset="/img/loading.gif" alt="vertical constraints" width="300"></p><p>这个时候我们运行这个程序，其实就可以看到上面的这个页面的Scroll效果。</p><p>有时候我们为了编辑的方便，特别是页面上东西多了之后，把界面上的完整显示会好一点. 我们可以把这个界面的ViewController的Simulated Size从Fixed改成Freeform，并给它一个很大的值，这个值要大于等于你ContentView里面的高度加vertical specing距离之和（我这里是1500）</p><p><img src="/2020/05/20/scrollview/viewcontrollersize.png" srcset="/img/loading.gif" alt="vertical constraints" width="300"></p><p>设置之后的界面如下，这时候你如果想编辑这两个Button，就不用滑来滑去了。</p><p><img src="/2020/05/20/scrollview/vcchangedview.png" srcset="/img/loading.gif" alt="vertical constraints" width="300"></p><h2 id="2-背后的道理"><a href="#2-背后的道理" class="headerlink" title="2. 背后的道理"></a>2. 背后的道理</h2><p>背后的道理其实很简单，我们先回顾一下这个821设置了什么。这个8其实就是设置了View，ScrollView，ContentView这三者之间的大小是完全贴合的(因为都是0), 如果不要贴合的话也可以设置成其他的值. 类似于手机壳，手机，手机膜的关系。这个时候我们只是设置了全贴合，但是没有给定具体宽高尺寸，而ScrollView需要指定宽高尺寸，2就是在给定这个尺寸。当我们设置equal widths的时候，实际上是设定了ScrollView的宽度等于ContentView的宽度，因为我们不需要横向滚动，所以这个值就是固定的。equal height同样的道理，但是我们需要纵向滚动，并且滚动的范围还不能确定，因此我们这里设置成equal height之后还要设置成Low Priority，即ScrollView的高度由ContentView来决定，ContentView本身的高度是Low Priority的，ContentView里面的vertical specing和Button的高度，这些都是High Priority的，因此ContentView的高度会先满足里面东西需要的高度，从而使ScrollView的滚动范围也满足里面东西需要的高度。</p><p>有时候要显示一段文字，用TextView，不知道要显示文字的长短，想要动态的TextView高度，这个时候把ScrollingEnable unselect（Scrolling里面的东西都不选），然后不用给定这个TextView的高度，这个TextView的高度就是动态的了。</p><p><img src="/2020/05/20/scrollview/textview.png" srcset="/img/loading.gif" alt="vertical constraints" width="300"></p><p>最后给大家留一个思考的问题，既然ContentView和ScrollView完全贴合，那么我把ScrollView背景色改成红色，在程序中可以看见这个红色吗。很简单，试试就知道。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot实现新冠肺炎病例数展示</title>
      <link href="/2020/03/29/covidtracker/"/>
      <url>/2020/03/29/covidtracker/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot实现新冠肺炎病例数展示"><a href="#SpringBoot实现新冠肺炎病例数展示" class="headerlink" title="SpringBoot实现新冠肺炎病例数展示"></a>SpringBoot实现新冠肺炎病例数展示</h1><p>现在新冠病毒在国外越闹越凶了，全球已经超过40万病例。我最近在YouTube上看到一个教你用SpringBoot做显示新冠肺炎数据的Web application的教程 （<a href="https://www.youtube.com/watch?v=8hjNG9GZGnQ&amp;t=2711s），挺适合像我这种对SpringBoot没啥了解的人，我照着做了一遍，写个文章把步骤捋一捋。" target="_blank" rel="noopener">https://www.youtube.com/watch?v=8hjNG9GZGnQ&amp;t=2711s），挺适合像我这种对SpringBoot没啥了解的人，我照着做了一遍，写个文章把步骤捋一捋。</a></p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>先说数据，现在全球用的数据基本都是John Hopkins的，那我们也用这个：</p><p><a href="https://github.com/CSSEGISandData/COVID-19/blob/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv" target="_blank" rel="noopener">https://github.com/CSSEGISandData/COVID-19/blob/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv</a></p><p><img src="/2020/03/29/covidtracker/repo.png" alt="UJH dataset" width="500"></p><p>这个数据从1月22开始记录，我们只用这个按Country, Province统计累计病历数的，还有其他的表，比如死亡数之类的，先不考虑。</p><p>再说工具，我们用SpringBoot做后台，因为是简单项目，没必要前后端分离，所以我们用Thymeleaf来作为HTML的模板，没有数据库。和上学期学过的 ASP .NET 框架很像， .NET里这个HTML模板叫Razor，而且和MVC这种结构类似。</p><p>我使用Intellij IDEA作为IDE，Java版本为11。Java 11有新加的Java.Net库，比较方便搞Http的数据请求，并且是一个LTS版本。</p><p>使用Maven作为包管理工具，因为要涉及到CSV文件的读取，所以我们用Apache Commons CSV这个工具来处理CSV文件。</p><p>这个程序和MVC模式差不多，只不过data model和view model不一样。需要了解一下基本的MVC模式即可。</p><h2 id="2-搭建环境"><a href="#2-搭建环境" class="headerlink" title="2.搭建环境"></a>2.搭建环境</h2><p>打开Intellij的new project，然后在左侧的工程模板里选择Spring Initializer</p><p><img src="/2020/03/29/covidtracker/start1.png" alt="template set" width="400"></p><p>注意这里选择Java 11</p><p>在下一个页面改改名字啥的，然后选择Maven Project</p><p><img src="/2020/03/29/covidtracker/start2.png" alt="project set" width="500"></p><p>在下一个页面里选择dependencies，Thymeleaf，Spring Boot DevTools和Spring Web。</p><p><img src="/2020/03/29/covidtracker/start3.png" alt="tools select" width="600"></p><p>打开Maven的pom.xml配置文件中的Java version以及IDE的Java的Target Bytecode Version是11，在Preferences, Build，Compiler里。</p><p><img src="/2020/03/29/covidtracker/start4.png" alt="java 11" width="600"></p><h2 id="3-创建Service"><a href="#3-创建Service" class="headerlink" title="3. 创建Service"></a>3. 创建Service</h2><p>我们需要程序自动去网站上获取数据，包括每次我运行他的时候和每天一个固定的时间。这个功能需要使用Spring Boot的Service功能来实现。</p><p>这里我们先创建一个叫CoronaVirusDataService的类，并把CSV数据的url复制过来，用Java.net做一个Http Request。</p><p><img src="/2020/03/29/covidtracker/getdata.png" alt="get data" width="600"><br>这个时候是没有输出的。</p><p>然后给这个类加上@Service和@PostConstruct的annotation，这个时候每次程序运行，都会创建一个Service的object，然后执行@PostConstruct，就能看到输出的数据。</p><p><img src="/2020/03/29/covidtracker/getdata2.png" alt="get data 2" width="600"></p><p><img src="/2020/03/29/covidtracker/printdata.png" alt="print data" width="600"></p><p>使用@schedule 定义每到一定的时间自动执行。这里我们定义的是每到一天的第一个小时自动执行。</p><p><img src="/2020/03/29/covidtracker/schedule.png" alt="schedule" width="500"></p><p>因为要用commons-csv处理这个SCV文件，在pom.xm里加上这个dependency。<br><img src="/2020/03/29/covidtracker/commonsCSV.png" alt="commons-csv" width="600"></p><p>参考commons-csv的doc里介绍的用法，把column名字改成我们dataset的。<br><img src="/2020/03/29/covidtracker/commonsUse.png" alt="csv doc" width="600"></p><p>这个CSV文件的每一行，即每个Province的数据，我们定义成MVC中的model类，用model里的attribute来表示column，最后用一个ArrayList保存这些model object。</p><p>最终程序如下：</p><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoronaVirusDataService</span> </span>{    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String VIRUS_DATA_URL = <span class="hljs-string">"https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv"</span>;    <span class="hljs-keyword">private</span> List<LocationStats> allStats = <span class="hljs-keyword">new</span> ArrayList<>();    <span class="hljs-function"><span class="hljs-keyword">public</span> List<LocationStats> <span class="hljs-title">getAllStats</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> allStats;    }    <span class="hljs-meta">@PostConstruct</span> <span class="hljs-comment">// execute after create the service instance</span>    <span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"* * 1 * * *"</span>) <span class="hljs-comment">//runs 1st hour of everyday</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fetchVirusData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>{        List<LocationStats> newStats = <span class="hljs-keyword">new</span> ArrayList<>();        HttpClient client =  HttpClient.newHttpClient();        HttpRequest request = HttpRequest.newBuilder().uri(URI.create(VIRUS_DATA_URL)).build();        HttpResponse<String> httpResponse = client.send(request,HttpResponse.BodyHandlers.ofString());        <span class="hljs-comment">//System.out.println(httpResponse.body());</span>        StringReader csvBodyReader = <span class="hljs-keyword">new</span> StringReader(httpResponse.body());        Iterable<CSVRecord> records = CSVFormat.DEFAULT.withFirstRecordAsHeader().parse(csvBodyReader);        <span class="hljs-keyword">for</span> (CSVRecord record : records) {            LocationStats locationStat = <span class="hljs-keyword">new</span> LocationStats();            locationStat.setState(record.get(<span class="hljs-string">"Province/State"</span>));            locationStat.setCountry(record.get(<span class="hljs-string">"Country/Region"</span>));            <span class="hljs-keyword">int</span> latestCases = Integer.parseInt(record.get(record.size() - <span class="hljs-number">1</span>));            <span class="hljs-keyword">int</span> prevDayCases = Integer.parseInt(record.get(record.size() - <span class="hljs-number">2</span>));            locationStat.setLatestTotalCases(latestCases);            locationStat.setDiffFromPrevDay(latestCases - prevDayCases);          <span class="hljs-comment">//System.out.println(locationStat);</span>          newStats.add(locationStat);        }        <span class="hljs-keyword">this</span>.allStats = newStats;    }}</code></pre><h2 id="4-创建Model"><a href="#4-创建Model" class="headerlink" title="4. 创建Model"></a>4. 创建Model</h2><p>model类的创建就比较简单了，我们只需要country，province，最新的数据和比前一天增长多少，然后自动generate getter and setter，就可以了。我们在这里不需要检测用户权限，也不需要验证用户输入（.NET在Model里使用attribute做这些事。</p><pre class=" language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocationStats</span> </span>{    <span class="hljs-keyword">private</span> String state;    <span class="hljs-keyword">private</span> String country;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> latestTotalCases;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> diffFromPrevDay;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDiffFromPrevDay</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> diffFromPrevDay;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDiffFromPrevDay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> diffFromPrevDay)</span> </span>{        <span class="hljs-keyword">this</span>.diffFromPrevDay = diffFromPrevDay;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> state;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(String state)</span> </span>{        <span class="hljs-keyword">this</span>.state = state;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCountry</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> country;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCountry</span><span class="hljs-params">(String country)</span> </span>{        <span class="hljs-keyword">this</span>.country = country;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLatestTotalCases</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> latestTotalCases;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLatestTotalCases</span><span class="hljs-params">(<span class="hljs-keyword">int</span> latestTotalCases)</span> </span>{        <span class="hljs-keyword">this</span>.latestTotalCases = latestTotalCases;    }    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"LocationStats{"</span> +                <span class="hljs-string">"state='"</span> + state + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", country='"</span> + country + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", latestTotalCases="</span> + latestTotalCases +                <span class="hljs-string">'}'</span>;    }}</code></pre><h2 id="5-创建Controller"><a href="#5-创建Controller" class="headerlink" title="5. 创建Controller"></a>5. 创建Controller</h2><p>controller Class需要加@Controller annotation。在constructer中引用service的object，这样做是为了能使用Service中返回的数据，这个也可以用@Autowired来做。</p><p>因为只有home page，所以用@GetMapping指定这个home函数的mapping路径是index，即”/“. 在这个view model(Spring Boot中的ui model)中直接加入attribute的名字和对应的值，在HTML页面中通过这个名字来寻找对应的值。这个返回的HTML页面是home页面，直接返回”home”, 就能够找到这个页面。</p><pre class=" language-hljs java"><span class="hljs-meta"><code class="language-hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeController</span> </span>{    <span class="hljs-keyword">final</span>    CoronaVirusDataService coronaVirusDataService;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HomeController</span><span class="hljs-params">(CoronaVirusDataService coronaVirusDataService)</span> </span>{        <span class="hljs-keyword">this</span>.coronaVirusDataService = coronaVirusDataService;    }    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">home</span><span class="hljs-params">(Model model)</span> </span>{        List<LocationStats> allStats = coronaVirusDataService.getAllStats();        <span class="hljs-keyword">int</span> totalReportedCases = allStats.stream().mapToInt(stat -> stat.getLatestTotalCases()).sum();        <span class="hljs-keyword">int</span> totalNewCases = allStats.stream().mapToInt(stat -> stat.getDiffFromPrevDay()).sum();        model.addAttribute(<span class="hljs-string">"locationStats"</span>,allStats);        model.addAttribute(<span class="hljs-string">"totalReportedCases"</span>, totalReportedCases);        model.addAttribute(<span class="hljs-string">"totalNewCases"</span>,totalNewCases);        <span class="hljs-keyword">return</span> <span class="hljs-string">"home"</span>;    }}</code></pre><h2 id="6-创建home-html页面"><a href="#6-创建home-html页面" class="headerlink" title="6. 创建home.html页面"></a>6. 创建home.html页面</h2><p>在resources/templates下新建一个home.html文件, 这个这个文件与controller返回的值相对应。</p><p>用的是Thymeleaf的模板，这个模板主要起三个作用: 1.是定义自己的attribute或者tag; 2.计算你定义的表达式; 3.应用你定义的逻辑。不了解没关系，可以打开Thymeleaf官网，找一些范例，修改一下。<br>只用看明白以下这两个例子，做这个程序就够了。</p><p><img src="/2020/03/29/covidtracker/thyme1.png" alt="Thymeleaf home" width="600"></p><p><img src="/2020/03/29/covidtracker/thyme2.png" alt="Thymeleaf table" width="600"></p><p>简单说明，th: 表示这个tab使用Thymeleaf语法。#{}表示message, ${}表示variable的值。</p><p><img src="/2020/03/29/covidtracker/thymecode.png" alt="use Thymeleaf" width="600"></p><p>在浏览器输入 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 现在看到是这样的界面<br><img src="/2020/03/29/covidtracker/initialpage.png" alt="HTML page" width="600"></p><p>这个界面现在显示了我们需要的数据，仅此而已，我们可以从BootStrap这个库里找点CSS样式美化一下。</p><p><img src="/2020/03/29/covidtracker/bootstrapset.png" alt="add Bootstrap" width="600"></p><p>找到Jumbotron的范例，改一改。</p><p><img src="/2020/03/29/covidtracker/jumbbutton.png" alt="jumbotron" width="600"></p><p>页面加上Jumbotron，是这种效果：</p><p><img src="/2020/03/29/covidtracker/jumbtron.png" alt="add jumbotron" width="500"></p><p>最后的HTML页面:</p><pre class=" language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword"><code class="language-hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>></span><span class="hljs-tag"><<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>></span><span class="hljs-tag"><<span class="hljs-name">head</span>></span>    <span class="hljs-tag"><<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=UTF-8"</span> /></span>    <span class="hljs-tag"><<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"</span> <span class="hljs-attr">integrity</span>=<span class="hljs-string">"sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>></span><span class="hljs-tag"></<span class="hljs-name">head</span>></span><span class="hljs-tag"><<span class="hljs-name">body</span>></span><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>></span><span class="hljs-tag"><<span class="hljs-name">h1</span>></span>Coronavirus Tracking application<span class="hljs-tag"></<span class="hljs-name">h1</span>></span><span class="hljs-tag"><<span class="hljs-name">p</span>></span>This application lists the current number of cases reported across the world<span class="hljs-tag"></<span class="hljs-name">p</span>></span><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"jumbotron"</span>></span>    <span class="hljs-tag"><<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"display-4"</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${totalReportedCases}"</span>></span><span class="hljs-tag"></<span class="hljs-name">h1</span>></span>    <span class="hljs-tag"><<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lead"</span>></span>total cases reported as of today<span class="hljs-tag"></<span class="hljs-name">p</span>></span>    <span class="hljs-tag"><<span class="hljs-name">hr</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"my-4"</span>></span>    <span class="hljs-tag"><<span class="hljs-name">p</span>></span>       <span class="hljs-tag"><<span class="hljs-name">span</span>></span>new cases reported since previous day<span class="hljs-tag"></<span class="hljs-name">span</span>></span>        <span class="hljs-tag"><<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${totalNewCases}"</span>></span><span class="hljs-tag"></<span class="hljs-name">span</span>></span>    <span class="hljs-tag"></<span class="hljs-name">p</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span><span class="hljs-tag"><<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table"</span>></span>    <span class="hljs-tag"><<span class="hljs-name">tr</span>></span>        <span class="hljs-tag"><<span class="hljs-name">th</span>></span>State<span class="hljs-tag"></<span class="hljs-name">th</span>></span>        <span class="hljs-tag"><<span class="hljs-name">th</span>></span>Country<span class="hljs-tag"></<span class="hljs-name">th</span>></span>        <span class="hljs-tag"><<span class="hljs-name">th</span>></span>Total cases reported<span class="hljs-tag"></<span class="hljs-name">th</span>></span>        <span class="hljs-tag"><<span class="hljs-name">th</span>></span>Changes since last day<span class="hljs-tag"></<span class="hljs-name">th</span>></span>    <span class="hljs-tag"></<span class="hljs-name">tr</span>></span>    <span class="hljs-tag"><<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"locationStat : ${locationStats}"</span>></span>        <span class="hljs-tag"><<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${locationStat.state}"</span>></span><span class="hljs-tag"></<span class="hljs-name">td</span>></span>        <span class="hljs-tag"><<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${locationStat.country}"</span>></span><span class="hljs-tag"></<span class="hljs-name">td</span>></span>        <span class="hljs-tag"><<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${locationStat.latestTotalCases}"</span>></span>0<span class="hljs-tag"></<span class="hljs-name">td</span>></span>        <span class="hljs-tag"><<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${locationStat.diffFromPrevDay}"</span>></span>0<span class="hljs-tag"></<span class="hljs-name">td</span>></span>    <span class="hljs-tag"></<span class="hljs-name">tr</span>></span><span class="hljs-tag"></<span class="hljs-name">table</span>></span><span class="hljs-tag"></<span class="hljs-name">div</span>></span><span class="hljs-tag"></<span class="hljs-name">body</span>></span><span class="hljs-tag"></<span class="hljs-name">html</span>></span></code></pre><p>页面效果:</p><p><img src="/2020/03/29/covidtracker/finalpage.png" alt="final page" width="600"></p><h2 id="7-Data-visualization"><a href="#7-Data-visualization" class="headerlink" title="7. Data visualization"></a>7. Data visualization</h2><p>那个视频里的程序到这里就结束了，其实除了把dataset的数据展示出来，data visualizaion部分能做的还有很多。</p><p>我自己尝试了先用group by统计每个国家感染人数的总和, 然后sort这个结果。Java里做groupby和sort真的太麻烦了。</p><pre class=" language-hljs java"><code class="language-hljs java">      model.addAttribute(<span class="hljs-string">"totalCasesCountry"</span>,sortByValue(totalCasesCountry(allStats)));    <span class="hljs-keyword">return</span> <span class="hljs-string">"home"</span>;}<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map<String, Integer> <span class="hljs-title">totalCasesCountry</span><span class="hljs-params">(List<LocationStats> locationStats)</span> </span>{    <span class="hljs-keyword">return</span> locationStats.stream()            .collect(Collectors.groupingBy(                    LocationStats::getCountry,                    Collectors.summingInt(LocationStats::getLatestTotalCases)));}<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <K, V> <span class="hljs-function">Map<K, V> <span class="hljs-title">sortByValue</span><span class="hljs-params">(Map<K, V> map)</span> </span>{    List<Map.Entry<K, V>> list = <span class="hljs-keyword">new</span> LinkedList<>(map.entrySet());    Collections.sort(list, <span class="hljs-keyword">new</span> Comparator<Object>() {        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o2, Object o1)</span> </span>{            <span class="hljs-keyword">return</span> ((Comparable<V>) ((Map.Entry<K, V>) (o1)).getValue()).compareTo(((Map.Entry<K, V>) (o2)).getValue());        }    });    Map<K, V> result = <span class="hljs-keyword">new</span> LinkedHashMap<>();    <span class="hljs-keyword">for</span> (Iterator<Map.Entry<K, V>> it = list.iterator(); it.hasNext();) {        Map.Entry<K, V> entry = (Map.Entry<K, V>) it.next();        result.put(entry.getKey(), entry.getValue());    }    <span class="hljs-keyword">return</span> result;}</code></pre><pre class=" language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string"><code class="language-hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table"</span>></span>    <span class="hljs-tag"><<span class="hljs-name">tr</span>></span><span class="hljs-comment"><!--        <th>State</th>--></span>        <span class="hljs-tag"><<span class="hljs-name">th</span>></span>Country<span class="hljs-tag"></<span class="hljs-name">th</span>></span>        <span class="hljs-tag"><<span class="hljs-name">th</span>></span>Total cases reported<span class="hljs-tag"></<span class="hljs-name">th</span>></span><span class="hljs-comment"><!--        <th>Changes since last day</th>--></span>    <span class="hljs-tag"></<span class="hljs-name">tr</span>></span>    <span class="hljs-tag"><<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"country : ${totalCasesCountry.keySet()}"</span>></span><span class="hljs-comment"><!--        <td th:text="${locationStat.state}"></td>--></span>        <span class="hljs-tag"><<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${country}"</span>></span><span class="hljs-tag"></<span class="hljs-name">td</span>></span>        <span class="hljs-tag"><<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${totalCasesCountry.get(country)}"</span>></span>0<span class="hljs-tag"></<span class="hljs-name">td</span>></span><span class="hljs-comment"><!--        <td th:text="${locationStat.diffFromPrevDay}">0</td>--></span>    <span class="hljs-tag"></<span class="hljs-name">tr</span>></span><span class="hljs-tag"></<span class="hljs-name">table</span>></span></code></pre><p>改动完之后是这样的:</p><p><img src="/2020/03/29/covidtracker/sorted.png" alt="groupby country" width="600"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Swift内存管理</title>
      <link href="/2020/02/18/iosarc/"/>
      <url>/2020/02/18/iosarc/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈Swift内存管理"><a href="#浅谈Swift内存管理" class="headerlink" title="浅谈Swift内存管理"></a>浅谈Swift内存管理</h1><p>主要内容参考这几篇文章：</p><p><a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" target="_blank" rel="noopener">https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html</a></p><p><a href="https://swiftrocks.com/memory-management-and-performance-of-value-types.html" target="_blank" rel="noopener">https://swiftrocks.com/memory-management-and-performance-of-value-types.html</a></p><p>本文有一定难度, 并不是面向Swift初学者。</p><h2 id="1-Swift-数据类型"><a href="#1-Swift-数据类型" class="headerlink" title="1.  Swift 数据类型"></a>1.  Swift 数据类型</h2><p>在swift中的数据类型，被分为两种， 一种叫value type， 一种叫reference type。这个value type就是每次赋值的时候传递值，创建一个新的copy， 每个copy之间没有关联，类似于Java中的primitive type；这个reference type就是每次赋值的时候会传递引用， 所有的引用会指向同一个内存中的值， 类似于Java中的non-primitive type。下图显示了常见的Value Type和Reference Type。</p><p><img src="/2020/02/18/iosarc/types.png" alt="swift data types" width="400"></p><h2 id="2-ARC简介"><a href="#2-ARC简介" class="headerlink" title="2.  ARC简介"></a>2.  ARC简介</h2><p>Swift的内存管理机制叫Automatic Reference Counting, 简称ARC。这个ARC比较特殊，与常见的其他语言如C/C++或者Java/C#不一样。常见的编程语言中，内存的分配是由程序来做的，比如定义一个变量，就得分配一块内存空间，不一样的地方在于内存的释放。C/C++中，内存的释放需要程序员手动进行，可玩性比较高，但有时候会出现分配的内存无法访问也无法释放的问题，造成内存泄漏。 </p><p>Java/C#内存管理机制叫Garbage Collect, 简称GC，在runtime虚拟机会进行GC process，这个GC process 比较复杂，而且在不同的虚拟机上实现的方法不同。有的是用引用计数器的方式执行，有的是用事件触发的方式执行，这个GC process本身需要花费一定的系统资源。ARC其实是对GC进行了一定的改进, 也是计数对象的引用个数，引用个数为0时，释放内存。ARC的过程是放在compile time的，swift compiler 在编译的过程中，在你的程序里自动插入一些用于释放内存的代码，运行的时候不再进行检查。 </p><h2 id="3-stack-memory-vs-heap-memory"><a href="#3-stack-memory-vs-heap-memory" class="headerlink" title="3.  stack memory vs heap memory"></a>3.  stack memory vs heap memory</h2><p>内存，就是电脑ARM中的空间， 在Swift中的逻辑上分为两种，一种叫stack memory， 一种叫heap memory。stack memory在栈上存储数据，需要数据的大小是个定值, 并且遵循先进后出的原则, 数据按照顺序排列，数据释放的时候就是这个数据对应的scope结束的时候, scope是静态的因此又被称作静态内存。比如一个method里的局部变量，在这个method被调用的时候被创建，在栈上分配一块区域，栈顶指针移动到这个数据区域的顶部，当这个method返回了以后，栈顶指针移动到这个数据区域的底部，释放这些局部变量。当method嵌套的时候，被调用的method后分配空间，先被释放。heap memory在heap上存储数据, 数据的大小是可变的，数据是非线性排列的, 分配释放的开销都比较高，scope是动态的，因此又被称为动态内存. 因此当我们在讨论内存管理的问题的时候，实际上就是在说heap memory上的数据如何释放的问题。</p><p>通常来说，stack memory中存储的是value type data, heap memory中存储的是reference type data. 但是对于String，Array，Dictionary，Set这几种数据类型，虽然属于value type，实际上长度都是不确定的，需要有一个内部的reference type来管理element的存储, 这个reference type在heap上。并且利用这个内部的reference type，Swift在执行copy这几种value type data的时候，采用了copy-on-write的优化。也就是说因为value type需要值传递，每次传递的时候要创建一个新的copy, 分配一个新的内存空间, 如果有很多String具有相同的值, 也就是说赋值之后没有去改变这个值, 就会造成内存空间的浪费. 使用copy-on-write之后, String传递值的时候实际上会先传递一个引用, 等到这个传递的值需要改变的时候, 再立即复制一个copy, 改变值, 传递这个值. 在逻辑上, 是值传递的过程, 但实际会有传递引用的过程. </p><pre class=" language-hljs swift"><span class="hljs-comment"><code class="language-hljs swift"><span class="hljs-comment">//Copy on Assignment</span><span class="hljs-keyword">let</span> emptyStruct = <span class="hljs-type">EmptyStruct</span>() <span class="hljs-comment">//address A</span><span class="hljs-keyword">let</span> copy = emptyStruct <span class="hljs-comment">//address B</span><span class="hljs-comment">//Copy on Write</span><span class="hljs-keyword">let</span> array = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <span class="hljs-comment">//address C</span><span class="hljs-keyword">var</span> notACopy = array <span class="hljs-comment">//still address C</span>notACopy = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] <span class="hljs-comment">//now address D</span></code></pre><p>在Swift的线程(thread)之间, heap memory是共享的, 而stack memory不共享, 每个thread有自己的stack memory. Swift中大部分都是能够值传递的value type data， 并且Swift鼓励大家能用value type就不用reference type, 这样一方面内存能得到优化, 另一方面又能够解决多线程之间冲突的问题, 还利于搞unit test. 因此如果一个class不需要Inheritance或者Type casting, 最好用struct代替。</p><h2 id="3-Strong-Reference-Cycle"><a href="#3-Strong-Reference-Cycle" class="headerlink" title="3.  Strong Reference Cycle"></a>3.  Strong Reference Cycle</h2><p>之前已经介绍过Swift的ARC机制，这种机制实际上存在一个问题，就是当两个或者几个object相互引用，形成一个引用环路。在环路上，如果要释放其中一个，需要先释放引用他的那个，按照这个环转了一圈又能转回来，导致这个环上的哪个object都释放不了。<br>例如这两个类：</p><pre class=" language-hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) { <span class="hljs-keyword">self</span>.name = name }    <span class="hljs-keyword">var</span> apartment: <span class="hljs-type">Apartment?</span> <span class="hljs-comment">//引用Apartment</span>    <span class="hljs-keyword">deinit</span> { <span class="hljs-built_in">print</span>(<span class="hljs-string">"\(name) is being deinitialized"</span>) }}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apartment</span> </span>{    <span class="hljs-keyword">let</span> unit: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(unit: <span class="hljs-type">String</span>) { <span class="hljs-keyword">self</span>.unit = unit }    <span class="hljs-keyword">var</span> tenant: <span class="hljs-type">Person?</span> <span class="hljs-comment">//引用Person</span>    <span class="hljs-keyword">deinit</span> { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Apartment \(unit) is being deinitialized"</span>) }}</code></pre><p>分别创建这两个类的instance并释放</p><pre class=" language-hljs swift"><span class="hljs-keyword">var</span> john: <span class="hljs-type"><code class="language-hljs swift"><span class="hljs-keyword">var</span> john: <span class="hljs-type">Person?</span><span class="hljs-keyword">var</span> unit4A: <span class="hljs-type">Apartment?</span>john = <span class="hljs-type">Person</span>(name: <span class="hljs-string">"John Appleseed"</span>)unit4A = <span class="hljs-type">Apartment</span>(unit: <span class="hljs-string">"4A"</span>)john!.apartment = unit4Aunit4A!.tenant = johnjohn = <span class="hljs-literal">nil</span>unit4A = <span class="hljs-literal">nil</span></code></pre><p>deinit这时候不会执行，output不会有结果显示。可以用Xcode自带的内存分析工具Debug Memory Graph来调试。</p><p>点击  <img src="/2020/02/18/iosarc/graphm.png" alt="new repository" width="200"> 按钮，在弹出的界面点击Person，可以看到如下的图：</p><p><img src="/2020/02/18/iosarc/cyclem.png" alt="strong reference cycle" width="500"> </p><p>如果删除第五行或者第六行的引用再运行，可以看到deinit的执行结果:</p><pre class=" language-hljs sh"><code class="language-hljs sh">John Appleseed is being deinitializedApartment 4A is being deinitialized</code></pre><p>要解决这个问题，需要把”Apartment” Class里的”tenant” Properity 加一个关键字weak。</p><pre class=" language-hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) { <span class="hljs-keyword">self</span>.name = name }    <span class="hljs-keyword">var</span> apartment: <span class="hljs-type">Apartment?</span>    <span class="hljs-keyword">deinit</span> { <span class="hljs-built_in">print</span>(<span class="hljs-string">"\(name) is being deinitialized"</span>) }}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apartment</span> </span>{    <span class="hljs-keyword">let</span> unit: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(unit: <span class="hljs-type">String</span>) { <span class="hljs-keyword">self</span>.unit = unit }    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> tenant: <span class="hljs-type">Person?</span>    <span class="hljs-keyword">deinit</span> { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Apartment \(unit) is being deinitialized"</span>) }}</code></pre><p>这个关键字的作用是把strong reference变成weak reference，在释放的时候只会看strong reference的个数，Apartment没有了Person的strong reference，两个instance就都能释放了。</p><p><img src="/2020/02/18/iosarc/graphweak.png" alt="weak reference" width="600"> </p><p>还有一个关键字，unowned，和weak作用差不多，唯一的区别是weak可以用在optional value，并且只能用var定义为variable，这个instance的值允许为nil；而owned只能用在non-optional value，可以用let定义为constant，这个instance的值不能为nil，一般是用在一个instance的lifetime一定会短于另一个的情况。比如人和信用卡，人可以没有信用卡，但是信用卡一定会有属于的人。</p><pre class=" language-hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>{    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> card: <span class="hljs-type">CreditCard?</span>    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) {        <span class="hljs-keyword">self</span>.name = name    }    <span class="hljs-keyword">deinit</span> { <span class="hljs-built_in">print</span>(<span class="hljs-string">"\(name) is being deinitialized"</span>) }}<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreditCard</span> </span>{    <span class="hljs-keyword">let</span> number: <span class="hljs-type">UInt64</span>    <span class="hljs-keyword">unowned</span> <span class="hljs-keyword">let</span> customer: <span class="hljs-type">Customer</span>    <span class="hljs-keyword">init</span>(number: <span class="hljs-type">UInt64</span>, customer: <span class="hljs-type">Customer</span>) {        <span class="hljs-keyword">self</span>.number = number        <span class="hljs-keyword">self</span>.customer = customer    }    <span class="hljs-keyword">deinit</span> { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Card #\(number) is being deinitialized"</span>) }}<span class="hljs-keyword">var</span> john: <span class="hljs-type">Customer?</span>john = <span class="hljs-type">Customer</span>(name: <span class="hljs-string">"John Appleseed"</span>)john!.card = <span class="hljs-type">CreditCard</span>(number: <span class="hljs-number">1234_5678_9012_3456</span>, customer: john!)</code></pre><p><img src="/2020/02/18/iosarc/unowned.png" alt="unowned reference" width="600"> </p><p>Java的GC中有WeakReference和SoftReference, SoftReference强于WeakReference，每一次执行GC的时候，如果一个object只有WeakReference，就会被清理，如果一个object只有SoftReference，GC会根据算法以及内存剩余考虑是否清理。</p><h2 id="4-Strong-Reference-Cycle-for-closures"><a href="#4-Strong-Reference-Cycle-for-closures" class="headerlink" title="4.  Strong Reference Cycle for closures"></a>4.  Strong Reference Cycle for closures</h2><p>Swift中的Closure相当于Java或者Python中的Lambda，就是一个匿名函数，用来让程序看上去更简洁。Closure在Swift里被当做Reference type，当一个instance里包含Closure，并且这个Closure用self引用了instance，这个时候也会造成Strong Reference Cycle.</p><pre class=" language-hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HTMLElement</span> </span>{    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">let</span> text: <span class="hljs-type">String?</span>    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> asHTML: () -> <span class="hljs-type">String</span> = {        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> text = <span class="hljs-keyword">self</span>.text {            <span class="hljs-keyword">return</span> <span class="hljs-string">"<\(self.name)>\(text)</\(self.name)>"</span>        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">return</span> <span class="hljs-string">"<\(self.name) />"</span>        }    }    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, text: <span class="hljs-type">String?</span> = <span class="hljs-literal">nil</span>) {        <span class="hljs-keyword">self</span>.name = name        <span class="hljs-keyword">self</span>.text = text    }    <span class="hljs-keyword">deinit</span> {        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\(name) is being deinitialized"</span>)    }}</code></pre><p>例如在上面这个class HTMLElement中，定义了一个closure用来把name和text生成HTML tab, “</p><p>some text</p>“ 或者 “<p>“. 这里加了关键字lazy，起性能优化的作用，这样在instance创建的时候不会执行这个closure，只有在需要执行的时候才会被执行一次。lazy关键字只能加在variable之前，constant不能用。</p><pre class=" language-hljs swift"><span class="hljs-keyword">var</span> paragraph: <span class="hljs-type">HTMLElement?</span> = <span class="hljs-type">HTMLElement</span>(name: <span class="hljs-string">"p"</span>, text: <span class="hljs-string"><code class="language-hljs swift"><span class="hljs-keyword">var</span> paragraph: <span class="hljs-type">HTMLElement?</span> = <span class="hljs-type">HTMLElement</span>(name: <span class="hljs-string">"p"</span>, text: <span class="hljs-string">"hello, world"</span>)<span class="hljs-built_in">print</span>(paragraph!.asHTML())<span class="hljs-comment">// Prints "<p>hello, world</p>"</span>paragraph = <span class="hljs-literal">nil</span> <span class="hljs-comment">//不能调用deinit</span></code></pre><p><img src="/2020/02/18/iosarc/closure.png" alt="closure strong reference cycle" width="600"> </p><p>要解决这个问题，和两个instance之间的strong reference cycle类似，需要用weak或者unowned关键字来去掉其中一个strong reference。因为这个问题中有HTMLElement instance不一定会执行这个closure，而closure一定对应一个HTMLElement instance，closure的lifetime小于instance，对于closure来说，instance不会为nil，所以用closure加unowned关键字引用instance。</p><pre class=" language-hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title"><code class="language-hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HTMLElement</span> </span>{    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">let</span> text: <span class="hljs-type">String?</span>    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> asHTML: () -> <span class="hljs-type">String</span> = {        [<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> text = <span class="hljs-keyword">self</span>.text {            <span class="hljs-keyword">return</span> <span class="hljs-string">"<\(self.name)>\(text)</\(self.name)>"</span>        } <span class="hljs-keyword">else</span> {            <span class="hljs-keyword">return</span> <span class="hljs-string">"<\(self.name) />"</span>        }    }    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, text: <span class="hljs-type">String?</span> = <span class="hljs-literal">nil</span>) {        <span class="hljs-keyword">self</span>.name = name        <span class="hljs-keyword">self</span>.text = text    }    <span class="hljs-keyword">deinit</span> {        <span class="hljs-built_in">print</span>(<span class="hljs-string">"\(name) is being deinitialized"</span>)    }}</code></pre><p>这里在closure里开始部分加的方括号叫做capture list, 用来匹配closure里的instance或者变量(例如delegate).</p><pre class=" language-hljs swift"><span class="hljs-built_in">lazy</span> <span class="hljs-keyword"><code class="language-hljs swift"><span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> someClosure = {    [<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">self</span>, <span class="hljs-keyword">weak</span> delegate = <span class="hljs-keyword">self</span>.delegate]    (index: <span class="hljs-type">Int</span>, stringToProcess: <span class="hljs-type">String</span>) -> <span class="hljs-type">String</span> <span class="hljs-keyword">in</span>    <span class="hljs-comment">// closure body goes here</span>}<span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> someClosure = {    [<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">self</span>, <span class="hljs-keyword">weak</span> delegate = <span class="hljs-keyword">self</span>.delegate] <span class="hljs-keyword">in</span>    <span class="hljs-comment">// closure body goes here</span>}</code></pre><p>加了unowned之后的reference关系图如下所示。</p><p><img src="/2020/02/18/iosarc/closure2.png" alt="closure strong reference cycle resolved" width="600"><br>这时候就可以释放HTMLElement instance和closure了。和之前一样，因为closure是引用的unowned的instance，closure不是optional，不能赋值nil，所以只能把nil赋值给instance。</p><p>最后回到一个很基本的问题，当我们打开assistant模式，放一个按钮，按住control拖一个outlet的时候，为什么这个outlet默认是weak的。仔细想想，你一定能明白。</p><p><img src="/2020/02/18/iosarc/button.png" alt="button" width="500"> </p><pre><code>2020年2月22日凌晨Clayton</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub新手笔记</title>
      <link href="/2020/01/19/gitinstruction/"/>
      <url>/2020/01/19/gitinstruction/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-新手笔记"><a href="#GitHub-新手笔记" class="headerlink" title="GitHub 新手笔记"></a>GitHub 新手笔记</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.  简介"></a>1.  简介</h2><p>GitHub是一个用于代码管理和交流的网站, git是一个管理GitHub上代码的命令行工具. GitHub也有Desktop的软件, 就是给那些命令行做一个界面, 功能还是那些. 还有一个付费软件叫GitKraken, 这个软件用学校的邮箱的GitHub账号可以免费, 界面更加炫酷并且多了一些追踪timeline, branch, 以及任务板之类的的功能, 在多人团队合作的时候可能会比较有用, 自己用就没必要了. 除此之外, 基本上常见的IDE上也都会支持version control功能, 可以在上面登录GitHub的账号, 会方便许多. 但是这种不一定靠谱. 我之前用Xcode做一个iOS的程序的时候, 用Xcode自带的git工具push写好的代码, 遇到过一些BUG.</p><p>总结来说, 可以用git命令行, GitHub Desktop, GitKraken(团队合作), IDE自带的工具(Xcode的感觉不靠谱). 本文只介绍命令行, 辅助使用GitHub Desktop.</p><h2 id="2-个人使用"><a href="#2-个人使用" class="headerlink" title="2.  个人使用"></a>2.  个人使用</h2><p>个人使用大部分情况就是这几个命令:</p><pre class=" language-hljs sh">git <span class="hljs-built_in"><code class="language-hljs sh">git <span class="hljs-built_in">clone</span>git add .git statusgit <span class="hljs-built_in">log</span> --onelinegit commit -mgit pushgit diff</code></pre><p>git clone: 从GitHub的remote端把repository下载到本地, 并且在本地建立一个repository, clone完之后会发现文件目录下会有一个自动生成的.git的文件, 这个文件就是用来记录你本地的repository信息的.</p><p>git add . : 把你新加入到这个repository的目录下的所有文件加入你的local repository. 简单来说就是添加文件.</p><p>git status: 显示你local repository的状态, 每次执行完一个操作可以用这个命令看看改了哪些东西.</p><p>git log –oneline: 显示你所有的操作记录. 不加–oneline的话会显示详细信息, 比如是谁修改的, 修改日期. 因为是自己使用, 一般看简要信息就够了.</p><p>git commit -m: 每次把程序修改完之后, 要commit一下, 并且加上一句话, 表示你确认这些修改. 这样你下次再该, 就只会显示你下一次改的东西, 这次的就不会显示. 相当于一个commit就是创建一个版本, 可以追踪每一次分别改了什么.</p><p>git push: commit之后把本地的repository的内容覆盖remote的repository, 简单来说就是更新GitHub上的代码.</p><p>举个例子: </p><ul><li><h3 id="先在GitHub网站上新建一个repository"><a href="#先在GitHub网站上新建一个repository" class="headerlink" title="先在GitHub网站上新建一个repository"></a>先在GitHub网站上新建一个repository</h3></li></ul><p><img src="/2020/01/19/gitinstruction/newrep.png" alt="new repository" width="500"></p><ul><li><h3 id="用clone命令把这个repository下载到本地"><a href="#用clone命令把这个repository下载到本地" class="headerlink" title="用clone命令把这个repository下载到本地"></a>用clone命令把这个repository下载到本地</h3>打开Command Prompt, 用cd命令来切换到要下载到的目录, 如果在Windows上要从C盘切换到其他盘, 直接输 e: (没有cd) 就是切换到E盘.</li></ul><p>从GitHub上复制那个repository的clone or download按钮的https url.</p><p>之后在命令行里输git clone + 那个复制的url</p><pre class=" language-hljs sh">e:\Git&gt;git <span class="hljs-built_in"><code class="language-hljs sh">e:\Git&gt;git <span class="hljs-built_in">clone</span> https://github.com/zhiyan93/individual.git</code></pre><ul><li><h3 id="用add命令给repository目录添加文件"><a href="#用add命令给repository目录添加文件" class="headerlink" title="用add命令给repository目录添加文件"></a>用add命令给repository目录添加文件</h3>这里在文件目录下加了一个叫123.txt的文件, 你的其他project文件也是一样的道理.</li></ul><p><img src="/2020/01/19/gitinstruction/add1.png" alt="add new file" width="200"></p><p>可以先用status命令查看一下</p><pre class=" language-hljs sh"><code class="language-hljs sh">git status</code></pre><p><img src="/2020/01/19/gitinstruction/add2.png" alt="status" width="500"></p><p>显示有一个文件Untrack.</p><p>再用git add . 把这个文件加进去, 并查看状态</p><pre class=" language-hljs sh"><code class="language-hljs sh">git add .git status</code></pre><p><img src="/2020/01/19/gitinstruction/add3.png" alt="added status" width="400"></p><p>这个文件就被加到local repository了. </p><ul><li><h3 id="用commit保存本地修改"><a href="#用commit保存本地修改" class="headerlink" title="用commit保存本地修改"></a>用commit保存本地修改</h3></li></ul><p>之后再用git commit -m定一下这个版本, 用git push上传到remote repository.</p><pre class=" language-hljs sh">git commit -m <span class="hljs-string"><code class="language-hljs sh">git commit -m <span class="hljs-string">"add 123.txt file"</span>git push</code></pre><p><img src="/2020/01/19/gitinstruction/add4.png" alt="commit" width="500"></p><p>打开GitHub网站,就能看到这个文件添加了进去, 点commit tab能看到每一次commit的记录.<br><img src="/2020/01/19/gitinstruction/add5.png" alt="commit record" width="500"></p><p>每一次改动之后用commit和push把本地的代码上传就行了.</p><ul><li><h3 id="用GitHub-Desktop或git-diff查看改动"><a href="#用GitHub-Desktop或git-diff查看改动" class="headerlink" title="用GitHub Desktop或git diff查看改动"></a>用GitHub Desktop或git diff查看改动</h3>用GitHub desktop这个软件能比较方便的看出来文件改了哪些地方, 比如我们再123.txt这个文件里输入12345678并保存, 打开GitHub desktop, 能看到这个change, 可以在这里直接commit + push, 也可以再命令行里做, 效果一样.</li></ul><p><img src="/2020/01/19/gitinstruction/add6.png" alt="GitHub Desktop" width="500"></p><p>这个比较改动也可以再命令行里用git diff来看, 但是显示效果没有在GitHub desktop里面的好. 比如我们再在123.txt文件里加上90, 输入 git diff.</p><pre class=" language-hljs sh"><code class="language-hljs sh">git diff</code></pre><p><img src="/2020/01/19/gitinstruction/add7.png" alt="git diff" width="400"></p><p>也能看出来改了哪些地方. 最后可以用git log –oneline看看之前的操作记录.</p><p>个人使用的话会这些基本够用了, 大多数情况下也就用的这些.</p><h2 id="3-小型团队合作"><a href="#3-小型团队合作" class="headerlink" title="3.  小型团队合作"></a>3.  小型团队合作</h2><ul><li><h3 id="collaborator模式"><a href="#collaborator模式" class="headerlink" title="collaborator模式"></a>collaborator模式</h3>用GitHub和其他人合作主要分两种模式, 一个是简单点的Collaborator模式, 就两三个人的话用这种模式比较高效. 一个是比较复杂的Contributer模式. Collaborator模式就是团队中的每个人都可以对这个repository push, 不需要pull request, 不需要其他人审查. 免费的GitHub账号最多可以在一个repository里设置三个Collabortor. 我用学校的邮箱注册过一个GitHub的账号, 这里邀请我的那个账号作为Collaborator.</li></ul><p><img src="/2020/01/19/gitinstruction/group3.png" alt="invite collaborator" width="400"></p><p>在setting里找到这个界面, 点击invite, 然后点copy invite link, 把那个链接发给要和你合作的那个人, 他点了这个链接相当于同意合作. 之后的效果是这个repository虽然是private的, 对于其他人都不可见, 但是Collaborator都可以看见. </p><p><img src="/2020/01/19/gitinstruction/group4.png" alt="collaboration repo" width="400"></p><p>上面这个图就是登录了学校的GitHub账号zhiyan18(图标1),并点击zhiyan93的GitHub账号(图标2)后看到的效果. zhiyan93的标记为private的repository可见了.</p><p>之后的使用方法和个人使用的差不多, 也是Git clone 到本地, 然后修改, git commit, git push 那一套流程.</p><p>我把123.txt那个文件里的文字用两个GitHub账号分别修改了一下, 然后push, 打开Commits界面, 就会看到如下图的现象. 两个头像分别Commit.</p><p><img src="/2020/01/19/gitinstruction/group5.png" alt="commits" width="400"></p><ul><li><h3 id="处理conflict"><a href="#处理conflict" class="headerlink" title="处理conflict"></a>处理conflict</h3>还有一种情况, 就是比如A修改了一段程序, push了, B也修改了, 但是修改的和A不一样, B在push的时候会出现conflict, git会提示这个conflict. 这时候B需要先pull, 把A做的修改合并到B的local repository, 再push. pull其实完成了fetch和merge两步操作, 即pull = fetch + merge. </li></ul><p><img src="/2020/01/19/gitinstruction/group7.png" alt="basic three repos" width="400"></p><p>如果B觉得A的更新有问题, 可以先用fetch把改动从云端的repository下载到本地的repository, 再用git diff查看A修改了哪些地方, 确定没问题了, 再merge. 如果B修改了A的更新, A需要再使用pull来保持本地的代码和云端的一致.</p><p>举个例子, 原来123.txt的文件内容是”zhiyan18 123”, 我先用zhiyan93的账号把123.txt文件的内容更新成” zhiyan18 123456 “, commit, push, 再用zhiyan18的账号把文件内容改成”zhiyan18 123789”, 这个时候是push不了的, 提示需要先pull. </p><p>使用GitHub Desktop push, 会提示有conflict, 这个时候会在文件里加入提示文字.</p><p><img src="/2020/01/19/gitinstruction/group8.png" alt="conflict in GitHub Desktop" width="400"></p><p>点击用visual studio code打开</p><p><img src="/2020/01/19/gitinstruction/group9.png" alt="conflict in vscode" width="500"></p><p>可以点击visual studio code 自带的合并工具提供的选项, 比如如果点击Accept Both Changes,就会把这两行都保留, 然后push, 可以在GitHub上看到如下效果.</p><p><img src="/2020/01/19/gitinstruction/group10.png" alt="accept both" width="400"></p><p> 一张图总结以上流程:</p><p><img src="/2020/01/19/gitinstruction/workflow.png" alt="basic work flow" width="500"></p><ul><li><h3 id="gitignore处理私密文件"><a href="#gitignore处理私密文件" class="headerlink" title="gitignore处理私密文件"></a>gitignore处理私密文件</h3>在团队合作中, 另一个需要考虑的问题就是很多文件不能分享, 比如用的很多API的secret key, 或者一些数据. 这时候可以用gitignore来解决.<br>举个例子.<br>在文件夹里有一个secret.txt的文件, 这个文件我们不想被别人看见. 新建一个名为.gitignore的文件, 在文件里写上”secret.txt”, 保存. </li></ul><p><img src="/2020/01/19/gitinstruction/ignore1.png" alt="gitignore" width="300"></p><p>把.gitignore这个文件加到repository里. 在命令行里输:</p><pre class=" language-hljs plain"><code class="language-hljs plain">git add .gitignoregit commit -m "add gitignore"</code></pre><p>这时候gitignore里的文件就都被忽略了, 用” git add . “也不会添加这个文件. 这个gitignore里还可以用符号匹配一些模式. 比如星号” * “是wildcard可以匹配任意字符. 这里的” /file.txt “并不表示子目录下的file.txt, 因为默认就会匹配所有子目录的文件, 这里斜杠的意思是只匹配根目录下的file.txt文件.</p><p>我们用” git log –oneline “来看看操作记录.</p><p><img src="/2020/01/19/gitinstruction/gitlog.png" alt="git log" width="500"></p><ul><li><h3 id="Project-Board-任务安排"><a href="#Project-Board-任务安排" class="headerlink" title="Project Board 任务安排"></a>Project Board 任务安排</h3>几个人合作时, 还可以点击repository的priject tab使用GitHub自带的Project Board功能. 用这个可以做一些简单的项目管理, 比如任务的安排和分配之类的, 提高合作者之间的沟通效率. 下图是我建立了一个tasks的to do column和包括zhiyan93, zhiyan18的两个progress column, 可以用鼠标拖动task来分配给每个人去做.</li></ul><p><img src="/2020/01/19/gitinstruction/group6.png" alt="project board" width="500"></p><p>最后要明白几个概念, 当我们用GitHub的时候, 每个人的代码其实有三份, 分别是云端的repository(remote), 本地的repository(local), 本地你正在写的那一份(working copy). 云端的那份在Git里叫做origion. 所以带origion的命令, 比如会有:</p><pre class=" language-hljs plain"><code class="language-hljs plain">git push origion master git push origion develop</code></pre><p>就是分别push到remote端的master branch和develop branch. 通常简单使用的话不需要分支, 直接就用 git push就好. 其他的操作同理.</p><p><img src="/2020/01/19/gitinstruction/open1.png" alt="basic terms" width="500"></p><p>每次你用commit命令, 实际上是把working copy覆盖到local repository, 每次你用push或者fetch, pull命令, 实际上是local repository与remote repository在进行同步.<br>两三个人合作的话会这些基本差不多了.</p><h2 id="4-大型团队合作或开源项目"><a href="#4-大型团队合作或开源项目" class="headerlink" title="4.  大型团队合作或开源项目"></a>4.  大型团队合作或开源项目</h2><p>我自己并没有用GitHub与其他人一起合作大型项目的经验, 所以这里写的只是我通过学习一些资料, 总结的一些基本操作. 详细的内容可以参考这几篇文章 </p><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">https://nvie.com/posts/a-successful-git-branching-model/</a> </p><p><a href="https://medium.com/@ruthmpardee/git-fork-workflow-using-rebase-587a144be470" target="_blank" rel="noopener">https://medium.com/@ruthmpardee/git-fork-workflow-using-rebase-587a144be470</a></p><ul><li><h3 id="branch-model简介"><a href="#branch-model简介" class="headerlink" title="branch model简介"></a>branch model简介</h3></li></ul><p>多人合作的一个基本概念就是Branch, 除了hotfix之外, 添加feature不会在master branch上直接修改. 这个master branch是一个稳定的版本, 供用户去使用的(production). 开发者会从develop branch上fork, 建立自己的分支, 然后在自己的分支上做自己的修改, commit之后push. </p><p>多人合作中, 除了以上提及到的三套代码(remote repository, local repository, working copy) 之外, 还有upstream repository. upstream 就是owner账号下的那一套代码, 用其他账号不能随意修改, 只能用branch提出pull request, 然后owner同意merge.</p><p>开源项目中每个人都使用自己的GitHub账号, 需要设置几个人当code reviewer, 来决定其他人写的branch能不能合并到develop branch, 并决定把develop branch 合并到master branch.</p><p><img src="/2020/01/19/gitinstruction/group2.png" alt="branching model" width="500"></p><p>主要用到的命令:</p><pre class=" language-hljs plain"><code class="language-hljs plain">git branch -a  //显示所有local branchgit branch feature1   //新建名为feature1的branchgit checkout -b feature1   //新建并切换到名为feature1的branchgit checkout feature1   //切换到名为feature1的branchgit remote add upstream [url of upstream]   //设置upstream repositorygit pull --rebase upstream master   //检查upstream上有没有其他人更新, 并把更新同步到本地git push origin feature1   //把更新push到你自己的remote repository feature1 branchgit checkout master   //切换到master branchgit push origin master   //跟新你自己的remote repository master branchgit branch -d feature1   //删除feature1 branch</code></pre><ul><li><h3 id="简单开源项目操作举例"><a href="#简单开源项目操作举例" class="headerlink" title="简单开源项目操作举例"></a>简单开源项目操作举例</h3></li></ul><p>举个例子:</p><ol><li><p>新建. 我用zhiyan18的账号新建了一个repository,名为group, 设置成public. </p></li><li><p>fork. 用zhiyan93的账号找到这个repository, 点击右上角的fork按钮 <img src="/2020/01/19/gitinstruction/fork.png" alt="" width="80"> , 把这个repository复制到zhiyan93账号下. 这里zhiyan18这个账号就是owner, zhiyan93这个账号是contributor (区别于之前讲的collaborator).</p></li><li><p>clone. 用zhiyan93这个账号clone 自己账号上的这个repository到本地.</p></li><li><p>upstream. 设置这个repository的upstream, 这样如果owner的代码被其他人更新了, 我们可以很方便的更新自己的repository, 加入别人的改动.</p><pre class=" language-hljs plain"><code class="language-hljs plain">git remote add upstream https://github.com/zhiyan18/group.git</code></pre></li><li><p>feature branch. 先确保在master branch上, 然后以master branch为基础, 新建一个名为feature1的branch, 在这个branch上修改程序. 不能直接在master branch上修改, 每次新的feature都要新建一个临时的branch, pull request被接受之后要删除.</p><pre class=" language-hljs plain"><code class="language-hljs plain">git checkout mastergit checkout -b feature1</code></pre><p>这个时候用</p><pre class=" language-hljs plain"><code class="language-hljs plain">git branch -agit checkout "分支名"</code></pre><p>可以查看所有分支, 并转到你需要编辑的分支. 每个分支都可以看作一套独立的代码.<br><img src="/2020/01/19/gitinstruction/allbran.png" alt="all branches" width="400"></p></li><li><p>edit branch. 这里我加入了一个txt文件.</p></li><li><p>pull. 检查upstream的master代码有没有更新.</p><pre class=" language-hljs plain"><code class="language-hljs plain">git pull --rebase upstream master</code></pre><p>这里设置了参数rebase, 这个参数有两个用处. 一个是你自己的commit和其他人的commit不会按照时间的先后混在一起, 把你的commit message全部放在当前其他人的commit之后, 便于阅读. 另一个是log里不会显示你的merge commit.</p></li><li><p>push. 把feature1分支push到contributor的remote repository.</p><pre class=" language-hljs plain"><code class="language-hljs plain">git push origin feature1</code></pre><p><img src="/2020/01/19/gitinstruction/pushfeature.png" alt="push feature to origin" width="500"></p></li><li><p>pull request. push之后, 在contributor的GitHub网站页面上, 切换到pull request tab, 可以看到有new pull request的按钮, 点击这个按钮, 就能向owner发起pull request.</p></li></ol><p><img src="/2020/01/19/gitinstruction/request.png" alt="pull request" width="500"></p><p><img src="/2020/01/19/gitinstruction/request2.png" alt="open pull request" width="500"></p><p>在owner账户(zhiyan18)那一端, 可以看见这个pull request.</p><p><img src="/2020/01/19/gitinstruction/mergepull.png" alt="merge pull request" width="500"></p><p>GitHub检查没有conflict之后, owner可以点击”Merge pull request”, 这个feature1 branch就被合并到了master branch.</p><p><img src="/2020/01/19/gitinstruction/added.png" alt="file added" width="500"></p><ol start="10"><li>push origin master. 这个时候虽然我们的pull request被接受, upstream的master branch更新了, 但是contributor的remote端还没有更新. 可以看到下图左上角有一行提示, “This branch is 2 commits behind behind zhiyan18 master”</li></ol><p><img src="/2020/01/19/gitinstruction/beforeadd.png" alt="origin master" width="500"></p><p>可以从upstream pull, 也可以从本地的代码push.</p><pre class=" language-hljs plain"><code class="language-hljs plain">git push origin master</code></pre><ol start="11"><li>删除feature1 branch<pre class=" language-hljs plain"><code class="language-hljs plain">git branch -d feature1</code></pre></li></ol><p>以上只是涉及到了开源项目中最基本的操作, 实际的情况要复杂很多, 我也不是搞得很懂, 只是把我知道的一些知识分享给大家.<br>谢谢!</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
